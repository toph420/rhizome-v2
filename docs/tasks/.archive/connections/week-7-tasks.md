# Week 7: Obsidian Sync Tasks

**Feature**: Connection Synthesis System - Obsidian Integration  
**Source PRP**: [docs/prps/connection-synthesis-system.md](/docs/prps/connection-synthesis-system.md)  
**Duration**: 5 days  
**Objective**: Implement bidirectional sync with Obsidian vault  

---

## Task T-024: Create syncToObsidian Function

### Task Identification
**Task ID**: T-024  
**Task Name**: Implement Core Obsidian Sync Function  
**Priority**: Critical  

### Context & Background

#### Source PRP Document
**Reference**: [docs/prps/connection-synthesis-system.md](/docs/prps/connection-synthesis-system.md) - Lines 1686-1823

#### Task Purpose
**As an** Obsidian user  
**I need** automatic sync of Rhizome connections  
**So that** connections appear as wikilinks in my Obsidian graph

#### Dependencies
- **Prerequisite Tasks**: Connection system operational (T-001 to T-023)
- **Parallel Tasks**: T-025 (companion section)
- **Integration Points**: Supabase storage, file system access

### Technical Requirements

#### Functional Requirements
- **REQ-1**: Download markdown from Supabase storage
- **REQ-2**: Query strong connections (‚â•0.8 strength)
- **REQ-3**: Generate companion section with wikilinks
- **REQ-4**: Write to Obsidian vault with backup

### Implementation Details

#### Files to Create
```
worker/lib/
‚îî‚îÄ‚îÄ obsidian-sync.ts - [CREATE: Sync functionality]
src/app/actions/
‚îî‚îÄ‚îÄ obsidian.ts - [CREATE: Server action wrapper]
```

#### Core Implementation
```typescript
// worker/lib/obsidian-sync.ts
import { createClient } from '@supabase/supabase-js'
import * as fs from 'fs/promises'
import * as path from 'path'

export async function syncToObsidian(
  documentId: string,
  userId: string,
  obsidianVaultPath: string,
  supabase: SupabaseClient
): Promise<{ success: boolean; error?: string }> {
  try {
    // 1. Get document metadata
    const { data: doc } = await supabase
      .from('documents')
      .select('title, storage_path')
      .eq('id', documentId)
      .single()
    
    if (!doc) {
      return { success: false, error: 'Document not found' }
    }
    
    // 2. Download markdown from storage
    const { data: markdownBlob } = await supabase
      .storage
      .from('documents')
      .download(`${doc.storage_path}/content.md`)
    
    if (!markdownBlob) {
      return { success: false, error: 'Markdown not found' }
    }
    
    const originalMarkdown = await markdownBlob.text()
    
    // 3. Query strong connections
    const { data: connections } = await supabase
      .from('connections')
      .select(`
        *,
        target_chunk:chunks!target_chunk_id (
          id,
          document_id
        )
      `)
      .or(`source_chunk_id.in.(
        SELECT id FROM chunks WHERE document_id = '${documentId}'
      )`)
      .gte('strength', 0.8)
      .order('strength', { ascending: false })
      .limit(50)
    
    // 4. Get target document titles
    const enrichedConnections = await enrichConnections(
      connections,
      supabase
    )
    
    // 5. Build companion section
    const companion = buildCompanionSection(
      documentId,
      enrichedConnections,
      doc.title
    )
    
    // 6. Merge with original
    const merged = mergeCompanionSection(
      originalMarkdown,
      companion
    )
    
    // 7. Backup existing if present
    const obsidianPath = path.join(
      obsidianVaultPath,
      `${sanitizeFilename(doc.title)}.md`
    )
    
    await createBackupIfExists(obsidianPath)
    
    // 8. Write to Obsidian vault
    await fs.writeFile(obsidianPath, merged, 'utf-8')
    
    return { success: true }
    
  } catch (error) {
    console.error('Sync failed:', error)
    return { 
      success: false, 
      error: (error as Error).message 
    }
  }
}

function buildCompanionSection(
  documentId: string,
  connections: any[],
  title: string
): string {
  const icons: Record<string, string> = {
    contradiction: '‚ö°',
    cross_domain_bridge: 'üåâ',
    structural_isomorphism: 'üèóÔ∏è',
    semantic_similarity: 'üîó',
    emotional_resonance: 'üí≠',
    methodological_echo: 'üîß',
    temporal_rhythm: '‚è±Ô∏è'
  }
  
  let section = `\n\n---\n\n## Rhizome Connections\n\n`
  section += `<!-- AUTO-GENERATED BY RHIZOME - DO NOT EDIT BELOW -->\n\n`
  
  // Group by connection type
  const grouped = groupByType(connections)
  
  for (const [type, conns] of Object.entries(grouped)) {
    const icon = icons[type] || 'üîó'
    section += `### ${icon} ${formatType(type)}\n\n`
    
    for (const conn of conns) {
      const targetTitle = conn.target_document_title || 'Unknown'
      const strength = (conn.strength * 100).toFixed(0)
      
      section += `- [[${targetTitle}]] (${strength}%)`
      
      if (conn.metadata?.shared_themes?.length > 0) {
        section += ` - ${conn.metadata.shared_themes.join(', ')}`
      }
      
      section += '\n'
    }
    
    section += '\n'
  }
  
  // Metadata footer
  section += `---\n\n`
  section += `**Rhizome Metadata**:\n`
  section += `- Document ID: \`${documentId}\`\n`
  section += `- Total Connections: ${connections.length}\n`
  section += `- Last Synced: ${new Date().toISOString()}\n`
  section += `- Sync Version: 1.0.0\n`
  
  return section
}

function mergeCompanionSection(
  original: string,
  companion: string
): string {
  const marker = '## Rhizome Connections'
  const endMarker = '<!-- END RHIZOME -->'
  
  // Find existing section
  const startIdx = original.indexOf(marker)
  
  if (startIdx !== -1) {
    // Replace existing
    let endIdx = original.indexOf(endMarker, startIdx)
    if (endIdx === -1) {
      // No end marker, replace to end of file
      return original.substring(0, startIdx) + companion
    } else {
      // Replace between markers
      return (
        original.substring(0, startIdx) +
        companion +
        '\n<!-- END RHIZOME -->' +
        original.substring(endIdx + endMarker.length)
      )
    }
  } else {
    // Append new section
    return original + '\n' + companion + '\n<!-- END RHIZOME -->'
  }
}

async function createBackupIfExists(filePath: string) {
  try {
    const existing = await fs.readFile(filePath, 'utf-8')
    const backupDir = path.join(
      path.dirname(filePath),
      '.rhizome-backups'
    )
    
    await fs.mkdir(backupDir, { recursive: true })
    
    const timestamp = Date.now()
    const backupPath = path.join(
      backupDir,
      `${path.basename(filePath, '.md')}-${timestamp}.md`
    )
    
    await fs.writeFile(backupPath, existing, 'utf-8')
    console.log(`Backup created: ${backupPath}`)
  } catch (err) {
    // File doesn't exist, no backup needed
  }
}

function sanitizeFilename(title: string): string {
  return title
    .replace(/[<>:"/\\|?*]/g, '-')
    .replace(/\s+/g, ' ')
    .trim()
}
```

### Acceptance Criteria

#### Given-When-Then Scenarios
```gherkin
Scenario 1: Successful sync
  Given document with strong connections
  When syncToObsidian() runs
  Then companion section added to markdown
  And wikilinks formatted correctly
  And file written to Obsidian vault

Scenario 2: Backup creation
  Given existing file in Obsidian
  When sync overwrites
  Then backup created in .rhizome-backups
  And timestamp included in backup name

Scenario 3: Wikilink formatting
  Given connection to "Philosophy of Mind" document
  When companion section generated
  Then wikilink appears as [[Philosophy of Mind]]
  And visible in Obsidian graph view
```

### Manual Testing Steps
1. Set up test Obsidian vault
2. Process document with connections
3. Run sync function
4. Open in Obsidian
5. Verify wikilinks in graph view

### Estimated Time
**4 hours** (complex file operations and formatting)

---

## Task T-025: Generate Companion Section

### Task Identification
**Task ID**: T-025  
**Task Name**: Create Well-Formatted Companion Section  
**Priority**: High  

### Context & Background

#### Task Purpose
**As an** Obsidian user  
**I need** readable connection sections  
**So that** connections are useful and navigable

### Requirements
- Group connections by type
- Include connection strength percentages
- Add shared themes/concepts
- Format for Obsidian readability

### Implementation Focus
- Use icons for connection types
- Sort by strength within groups
- Include metadata footer
- Preserve Obsidian frontmatter

### Estimated Time
**2 hours** (formatting and testing)

---

## Task T-026: Implement Backup System

### Task Identification
**Task ID**: T-026  
**Task Name**: Non-Destructive Backup System  
**Priority**: High  

### Context & Background

#### Task Purpose
**As a** safety measure  
**I need** automatic backups before sync  
**So that** no data is lost during updates

### Implementation Details
```typescript
// Backup strategy
const backupStrategy = {
  location: '.rhizome-backups/',
  naming: '{filename}-{timestamp}.md',
  retention: 10, // Keep last 10 backups
  cleanup: 'daily'
}

// Cleanup old backups
async function cleanupOldBackups(
  backupDir: string,
  retentionCount: number
) {
  const files = await fs.readdir(backupDir)
  const sorted = files.sort((a, b) => {
    // Extract timestamp and sort
    const timeA = parseInt(a.match(/\-(\d+)\.md$/)?.[1] || '0')
    const timeB = parseInt(b.match(/\-(\d+)\.md$/)?.[1] || '0')
    return timeB - timeA
  })
  
  // Delete old backups beyond retention
  for (let i = retentionCount; i < sorted.length; i++) {
    await fs.unlink(path.join(backupDir, sorted[i]))
  }
}
```

### Estimated Time
**2 hours**

---

## Task T-027: Conflict Resolution

### Task Identification
**Task ID**: T-027  
**Task Name**: Handle Sync Conflicts  
**Priority**: Medium  

### Context & Background

#### Task Purpose
**As a** conflict resolution  
**I need** clear rules for conflicts  
**So that** Rhizome remains source of truth

### Conflict Rules
1. Rhizome always overwrites companion section
2. User content above marker preserved
3. Manual edits to companion section lost
4. Clear warnings in companion header

### Estimated Time
**1.5 hours**

---

## Task T-028: Obsidian Graph Integration Testing

### Task Identification
**Task ID**: T-028  
**Task Name**: Validate Obsidian Graph View Integration  
**Priority**: Medium  

### Testing Protocol
1. Sync 3+ documents with connections
2. Open Obsidian graph view
3. Verify wikilinks create edges
4. Test filtering by connection type
5. Validate bidirectional links

### Validation Checklist
- [ ] Wikilinks appear as nodes
- [ ] Connections show as edges
- [ ] Graph navigable
- [ ] No broken links
- [ ] Performance acceptable

### Estimated Time
**2 hours**

---

## Week 7 Summary

### Total Estimated Time
- T-024: 4 hours (Core sync function)
- T-025: 2 hours (Companion formatting)
- T-026: 2 hours (Backup system)
- T-027: 1.5 hours (Conflict resolution)
- T-028: 2 hours (Integration testing)
- **Total**: 11.5 hours

### Critical Path
T-024 ‚Üí T-025 ‚Üí T-026 ‚Üí T-028

### Validation Gate (End of Week 7)
- [ ] Sync function operational
- [ ] Companion section well-formatted
- [ ] Backup system working
- [ ] Wikilinks visible in graph
- [ ] No data loss during sync

### Key Deliverables
1. Working Obsidian sync with wikilinks
2. Non-destructive backup system
3. Graph view integration verified
4. Conflict resolution documented

---

**Document Version**: 1.0.0  
**Last Updated**: 2025-09-28  
**Week**: 7 of 8  
**Status**: Ready for Implementation